package es.uned.tlp.mapgenerator;

/**
 * Main class for generating a battery of tests.
 */
public class MainBattery {
    public static void main(final String[] args) {
        final BatteryParameters params = BatteryParameters.fromCommandLine(args);

        if (params == null) {
            showUsage();
            return;
        }

        System.out.println(generateBattery(params));
    }

    private static void showUsage() {
        System.out.println("Usage: java -jar batteryGenerator.jar <number_of_tests>");
        System.out.println("\t\t<number_of_maps>: (int > 0) Number of tests in the generated battery");
    }

    /**
     * Generates a battery of solvable maps in the battery format as defined by the verification tool.
     * @param params Parameters for the battery to be generated.
     * @return A String-representation of the battery.
     */
    private static String generateBattery(final BatteryParameters params) {
        final StringBuilder sb = new StringBuilder();

        // All possible map sizes which might be generated by this function.
        // The have been chosen arbitrarily but keeping the dimensions relatively
        // low to avoid maps which take too long to be resolved.
        final MapSize[] mapSizes = new MapSize[] {
                new MapSize(4, 4),
                new MapSize(4, 8),
                new MapSize(8, 4),
                new MapSize(5, 9),
                new MapSize(9, 5),
                new MapSize(10, 10),
                new MapSize(10, 11),
                new MapSize(11, 10),
                new MapSize(15, 12),
                new MapSize(12, 12)
        };

        int mapsOfEachSize = params.numberOfMaps / mapSizes.length;
        // If we can't even generate one map of each size, simply do not generate the higher dimensions
        if (mapsOfEachSize == 0) {
            mapsOfEachSize = 1;
        }

        final MapGenerator mgen = new MapGenerator();

        int generatedMaps = 0;

        while (generatedMaps < params.numberOfMaps) {
            final int nextSizeIndex = generatedMaps / mapsOfEachSize;
            final MapSize nextSize = mapSizes[nextSizeIndex];
            final SingleMapParameters mapParams = new SingleMapParameters(
                    nextSize.width,
                    nextSize.height,
                    getTendencyToGrow(nextSize));
            final int[][] map = mgen.generateMap(mapParams);

            sb.append(String.format("(\"Test %d\",%s,%s,True)",
                    generatedMaps+1,
                    MapUtils.mapToString(map, false),
                    MapUtils.adjacenciesToString(MapUtils.getAdjacencies(map))))
                .append(System.getProperty("line.separator"));

            generatedMaps++;
        }

        final String withExtraNewLine = sb.toString();
        return withExtraNewLine.substring(0, withExtraNewLine.length() - 1);
    }

    /**
     * Returns a random tendency to grow for the regions of a map.
     * The tendency will be in a range which depends on the map size,
     * to try and create maps solvable in a reasonable time.
     * @param size Size of the map.
     * @return A growth tendency for a map of that size.
     */
    private static int getTendencyToGrow(final MapSize size) {
        final int surface = size.height* size.width;
        int maxValue = 100;
        int minValue = 1;

        if (surface < 50) {
            // No need to try and limit the number of regions
            maxValue = 20;
        } else if (surface < 100) {
            minValue = 20;
            maxValue = 60;
        } else if (surface < 150) {
            minValue = 50;
            maxValue = 70;
        } else {
            minValue = 60;
        }

        return MapUtils.getRandomIntInclusive(minValue, maxValue);
    }

    /**
     * The size of map.
     */
    private static class MapSize {
        public final int width;
        public final int height;

        public MapSize(final int width, final int height) {
            this.width = width;
            this.height = height;
        }
    }
}
